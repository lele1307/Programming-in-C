Neill's Adventure Language TEST Documentation
The project content mainly includes two parts, they are parser and interpreter.

1.Structure

Here are their main components:
nal.mk
    parser
    {
        parse.c
        parse.h
        tparse.c
    }
    interpreter
    {
        interp.c
        interp.h 
        tinterp.c
    }

They are all compiled by nal.mk 
    eg: make -f nal.mk parse testparse || make -f nal.mk interp testinterp

2.Function
The correct and incorrect expressions of the functions are presented in different .nal files.
<PRINT>: If using an undefined variable, the program would be error and exit.
<INC>:If using an undefined variable, the program would be error and exit.


3.Test 

    ① Parser
        Due to the recursive nature of this assignment, I try to use different .nal files to test corresponding functions.
        Among them, the parse_allright file contains all the correct syntax formats.
        In addition, parse tests the operation of all the provided files.
        
        parse_allright.nal -> test all correct situations

        testwrong1.nal 
        -> FILE && JUMP
        testwrong2.nal
        -> STRUCT '{' and '}' pairing
        testwrong3.nal
        -> PRINT && PRINTN 
            {
                void VARCON
                void CON
                void STRCON
                void NUMCON
                void NUMVAR_STRVAR
            }
        testwrong4.nal
        -> INC && RND && INNUM
            {
                void INC_RND
            }
        testwrong5.nal
        -> SET
            {
                void SET
            }
        testwrong6.nal
        -> IN2STR
            {
                void IN2STR
            }

        testwrong7.nal
        testwrong8.nal
        -> IF
            {
                void IF
            }
            **testwrong7.nal test STRUCT '{'and'}' pairing.
            **testwrong8.nal test IF grammer. 
            
    ② Interpreter
        Interpreter is an execution function based on the parser. Therefore, the interpreter function corresponding 
        to each function will be executed before return.Because the error condition will directly terminate the program, 
        in order to test the error condition, I wrote the bool test function to determine the execution of all functions.
        The following .nal files correspond to different detection functions：
        
        inte_allright.nal 
        -> 
            basic function{
                void InputFile
                Program *init_P
                void prog_free
                int TEST_SAMEVALNAME
                char *Getname
                char *GetSTRCON
                char *ROT
            }

        inte_test1.nal 
        -> 
            PRINT && SET && RND && INC && INPUT && JUMP
            {
                void SETNUM
                void SETSTR
                void PRINT
                void PRINT_Plain
                void PRINT_ROT13
                void RND
                void INC
                void INNUM
                void IN2STR_IN
                void IN2STR_IN_Single
                void JUMP
            }

        inte_test2.nal 
        ->
            IF (ALL RIGHT CONDITION)
            {
                void IF_RECORD
                void IF_CHECK (TRUE)
                void IF_SET
                void IFGREATER
                void IFEQUAL
            }
    
        inte_test3.nal && inte_test5.nal 
        ->
            FILE && ABORT
            {
                void READFILE
                void CopyVal
            }

        inte_test4.nal 
        ->
            IF (ALL ERROR CONDITION)
            {
                void IF_RECORD
                void IF_CHECK (FALSE)
                void IF_SET
            }
4.Problems and Solutions

    Solved Main Problems
    ① Memory leak
     - When some errors occur, the program will automatically terminate, 
     so there may be some cases where the memory is not released normally.
        #define FREE
        #define FREE_STR
    Added FREE function before terminating the program.

    ② Memory leak that ends the program after jumping to other files
    An array of structures is referenced.
    Storing the read content after executing FILE into a dynamic array and free up space uniformly.

    ③All variables are GLOBAL
    Establish an array structure for storing variables separately, and copy content to the variable 
    array at any time when jumping to a new file.

    Unsolved Problems
    After the program reads the content of the file, it is stored in the array as required, 
    but if the file has a format error, such as: the string is missing a single double quote or a pound sign. 
    The error message generated by the program after processing the array may not be able to accurately report the error.

5.Self judgment

    This experience gave me a deep understanding of the concept of recursion. Recursion itself has a problem of time and 
    memory consumption, but it is very simple in structure.But there is no easy method to test the code.

    I mainly used the Boolean test framework, converted a function to a boolean function with a return value, run test () 
    at the beginning of the program to test a specific .nal file which including all different situations.

    When writing the make file, the 'parse' 'interp' and 'exten' are processed separately, which results in partially duplicated 
    code. In addition, during the testing, the modifying needs to update two or three parts at the same time, which brings a lot 
    of workloads. This is one of the shortcomings of my project.



